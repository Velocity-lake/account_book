## 目标
- 鼠标滚轮在首页总览的任意位置都能滚动页面。
- 当指针悬停在可纵向滚动的“小区域”（例如 `Treeview`、可滚动 `Canvas`、列表等）上时，优先滚动该小区域；否则滚动整页（外层纵向 `Canvas`）。

## 现状诊断
- 首页页面类：`ui_dashboard.py` 中的 `DashboardPage`。
- 当前滚轮处理：`ui_dashboard.py:192-194` 的 `_on_mousewheel` 无论指针在哪，都调用 `self.vcanvas.yview_scroll(...)`，因此无法优先滚动局部组件。
- 绑定覆盖范围：`ui_dashboard.py:62,67-68,80-82` 已在多个容器上绑定 `<MouseWheel>`，但逻辑固定滚动外层页面。

## 修改方案
- 调整滚轮逻辑：修改 `ui_dashboard.py:192-194` 的 `_on_mousewheel` 为以下策略：
  1) 读取 `event.widget`；若它（或其最近的可滚动父级）具有 `yview` 能力且当前存在可滚动空间，则对该 widget 执行 `yview_scroll`。
  2) 否则，回退到页面级滚动：`self.vcanvas.yview_scroll(...)`。
  3) 返回 `"break"`，避免事件继续冒泡造成重复滚动。
- 可滚动判断：使用 `widget.yview()` 返回的 `(first, last)` 判断：当 `first>0` 或 `last<1`，表示确有可滚动空间；同时根据 `delta` 方向做边界保护，避免越界无效滚动。
- 绑定范围优化：在 `build_ui` 内追加一次 `self.vcanvas.bind_all("<MouseWheel>", self._on_mousewheel)`，确保“任意位置”都能触发；保留原有局部绑定以兼容现有行为。
- 横向滚动保持：保留已实现的 `<Shift-MouseWheel>` 水平滚动，不改动图表横向滚动（`ui_dashboard.py:183-185`）。

## 验证方案
- 启动应用，进入首页总览：标题区、图表区、列表（`tree_accounts`、`tree_recent`）、右侧面板等位置逐一测试滚轮。
- 当指针在 `Treeview` 上：应优先滚动该表体；离开后滚动整页。
- 在没有局部可滚动控件处：滚轮应滚动整页。
- 测试边界：在页首/页尾及表首/表尾滚动，确认不会出现反向空滚或抖动。
- 保证 Windows 下 `event.delta` 为 120 的倍数，滚动步进符合预期。