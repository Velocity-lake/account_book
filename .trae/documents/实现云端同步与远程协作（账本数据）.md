## 现状
- 数据持久化为本地 JSON 文件：`c:\Users\gang.luo\Documents\trae_projects\accout_book\data\ledger.json`（`storage.py:7-10`）
- 读写核心：加载 `load_state`（`storage.py:47-77`），保存 `save_state`（`storage.py:79-83`），备份 `backup_state`（`storage.py:84-91`）
- 当前无网络/云端同步逻辑；所有操作离线在本机完成。

## 目标
- 在多台设备上运行本软件时，能够实时或近实时共享同一份账本数据，并进行读写操作。
- 保证数据完整性（原子写入、并发控制、冲突处理与备份）。

## 方案选型
- 方案 A（最快落地）：云盘文件同步（OneDrive/Dropbox/坚果云）+ 应用内文件监听与并发保护
  - 优点：无需自建后端、部署成本低、支持离线后再同步
  - 风险：多端同时写入可能产生冲突，需要在应用层做原子写与冲突提示
- 方案 B（可扩展）：新增远程 API 后端（FastAPI/Flask）+ 客户端存储抽象，服务器持久化（PostgreSQL/SQLite）
  - 优点：可控并发、权限与审计、可做实时广播（WebSocket/SSE）
  - 风险：需部署后端、网络可用性要求更高
- 方案 C（托管服务）：使用 Supabase/Firebase 等托管数据库与实时通道
  - 优点：开箱即用的实时能力与鉴权
  - 风险：需适配 Python 客户端与数据模型迁移、成本与学习曲线

## 推荐路线
- 两阶段实施：先采用 方案 A 快速满足同步（近实时），再按需推进 方案 B 获得更强的协作与控制能力。

## 阶段 A：云盘同步的具体实现
1) 可配置数据目录（将账本放入云盘）
- 为 `DATA_DIR/LEDGER_PATH` 增加外部配置（环境变量或设置文件），覆盖 `storage.py:7-10` 默认路径
- 指向云盘中的目录，例如 `C:\Users\<你>\OneDrive\account_book\data`

2) 原子写入与文件锁
- 保存时使用临时文件写入 + `os.replace` 替换，实现原子性（避免半写入被云盘同步）
- 跨平台文件锁（Windows 可用 `msvcrt` 或第三方 `portalocker`），`save_state`（`storage.py:79-83`）扩展为锁定-写入-释放
- 在写入前比较文件 `mtime/etag`，避免覆盖其他设备刚刚写入的数据

3) 变更检测与自动刷新
- 启动后为 `LEDGER_PATH` 注册文件监听（`watchdog`），当云盘同步带来文件更新时：
  - 自动触发 `load_state`（`storage.py:47-77`）重新加载
  - UI 显示“已从云端刷新”的状态提示

4) 冲突与备份
- 检测写入冲突时：先执行 `backup_state`（`storage.py:84-91`）保存本地版本，再提示用户选择“覆盖/合并”
- 简单策略：最新写入优先 + 自动备份保底；进阶策略可做行级合并（按 `transactions` 的 `id` 去重合并）

5) 使用指南
- 所有设备将“数据目录”设置到同一云盘路径
- 避免在两台设备上同时进行大量编辑；若需要，确保应用的冲突提示与备份生效

## 阶段 B：远程后端的具体实现
1) 服务端
- 使用 FastAPI 提供 `/state`、`/accounts`、`/transactions` 等 REST API，持久化到 PostgreSQL（或 SQLite）
- 并发控制：版本号/时间戳 + 乐观锁；返回 `etag` 供客户端校验
- 可选实时：WebSocket/SSE 广播增量变更

2) 客户端
- 抽象存储层：定义 `StorageBackend` 接口（读写/备份/变更订阅）
  - 实现 `LocalJsonBackend`（沿用现有 JSON 流程）和 `RemoteApiBackend`（HTTP 请求）
- 在调用点以接口替换当前 `storage.py` 的直接文件读写，保持 UI 逻辑基本不变

3) 认证与安全
- 鉴权：JWT（服务端颁发），HTTPS 访问
- 不在日志中打印敏感信息；客户端保存令牌于安全位置

4) 离线与同步
- 客户端维护本地缓存（JSON）；网络恢复时与服务端进行增量双向同步

5) 依赖与配置
- 服务端：`fastapi`、`uvicorn`、`sqlalchemy`（或 `psycopg2`）
- 客户端：`requests`（或 `httpx`）、可选 `watchdog`（阶段 A 已用）
- 配置通过 `.env` 或应用设置页管理

## 验证与迁移
- 启动前备份现有 `ledger.json`（`backup_state`）
- 在两台设备上进行：
  - 打开应用 → 修改交易 → 观察另一台设备自动刷新（阶段 A）
  - 并发写入测试：确认锁与冲突提示有效；检查备份文件生成
- 编写单元测试覆盖：原子写入、锁定、冲突检测、文件监听回调

## 预期代码改动（确认后执行）
- `storage.py`：支持外部路径配置；实现原子写/锁/mtime 检查
- `ui_settings.py`：新增“数据目录”设置与同步状态展示
- `sync/file_watch.py`（新模块）：封装 `watchdog` 文件监听并回调刷新
- `storage_backend.py`（新模块）：定义 `StorageBackend` 接口与 `LocalJsonBackend`
- `remote/backend.py`（新模块，阶段 B）：`RemoteApiBackend` 实现
- （阶段 B）`server/` 目录：FastAPI 服务端基础骨架

## 取舍与建议
- 如果你希望尽快实现多设备同步且不搭建服务器，先选 方案 A；后续若需要权限控制、多人协作、审计与更稳定的并发，再升级到 方案 B。

请确认采用“两阶段路线（A→B）”，或告知倾向的方案，以便我开始具体实现。